#!/usr/bin/env python
# get_if_chromosome_rearranged_func_AFTER_MCscan_simplified.py
__author__ = "Wayne Decatur" #fomightez on GitHub
__license__ = "MIT"
__version__ = "0.1.0"


# get_if_chromosome_rearranged_func_AFTER_MCscan_simplified.py by 
# Wayne Decatur (really a simplification of what I do looking at output of 
# Habiabo Tang's 
# https://github.com/tanghaibao/jcvi/blob/master/graphics/dotplot.py )
# ver 0.1
#
#*******************************************************************************
# Verified compatible with Python 2.7 and Python 3,6; JCVI/MCscan are currently 
# only in Python 2.7, but you can run it in a kernel spawned with 3.6 in the
# same session where JCVI/MCscan previously run. (The repo at 
# https://github.com/fomightez/mcscan-binder will spawn a Jupyter environment 
# capable of both.)
#
#
# PURPOSE: Takes an anchors file made by MCscan for a single chromosome and
# returns if the chromosome (or genome for single chromosome genomes such as
# mitochondria) is rearranged. Also needs associated `.bed` files.
#
# There is a version that just reworks the code from the `dotplot.py` but that
# was way longer than it needed to be because of the interconnectedness of the 
# jcvi package parts, and so this oversimplifies what I assume
# `get_if_chromosome_rearranged_func_based_on_mcscan.py` does. (There is no one-
# to-one correspondance between the two implementations worked out.)
#
# Instead of requiring a sorted BED file among the input, i.e., so numerically 
# gene position ascending, I am going to use a simplified approach 
# to determine order using coordinates in BED file. This is because from 
# several places I have seen different approaches to how genes on other strand 
# handled, see below about 'BEDOPS' and related resources. Since my approach
# will be simplified, there is a tiny chance it might come out with orders of
# otholog pairs shifted in two single chromosomes genomes when actually not.
# It is best to use `get_if_chromosome_rearranged_func_based_on_mcscan.py` if
# that is possible because it is more thorough about positions. (You can always 
# confirm the result of this simplified script by checking for rearrangement 
# using the `dotplot.py script of jcvi/MCscan. Without rearrangement, every 
# point will be along the diagonal; deviation from that line for any gene means
# a rearrangement has occured.) Likewise, this simplified script will only work 
# with a single chromosome (or single-chromosome genome). Again, use 
# `get_if_chromosome_rearranged_func_based_on_mcscan.py` if you need overview
# for multiple chromosomes.
#
# 
#
# Written to run from command line or imported into/pasted/loaded inside a 
# Jupyter notebook cell. See below `TO RUN` below.
#
#
# USE:
# Intended to be used after MCscan run; I suggest luanching binder session
# from https://github.com/fomightez/mcscan-binder in order to use MCScan to 
# perform the `python2 -m jcvi.compara.catalog ortholog` step.
# 
#
# See `get_if_chromosome_rearranged_func_based_on_mcscan.py` for intermediate 
# version that actually is more thorough.
#
#
#
#
#
#
#
#
#
# If you are Wayne, see `Collecting yeast XXXXX XXXXXX (XXXXXX) May 2018.md` for 
# impetus behind this script.
#
#
#
# Dependencies beyond the mostly standard libraries/modules:
#
#
#
# VERSION HISTORY:
# v.0.1. basic working version

#
# To do:
# -  
#
#
#
# TO RUN:
# Examples,
# Enter on the command line of your terminal, the line
#-----------------------------------
# python get_if_chromosome_rearranged_func_based_on_mcscan.py anchors_file
#-----------------------------------
#
# 
#
#
# To use this after importing/pasting or loading into a cell in a Jupyter 
# notebook, specify at the anchor file in the 
# call to the main function similar to below:
# get_if_chromosome_rearranged("S288c.DBVPG6765.anchors") 
# 
# That file `S288c.DBVPG6765.anchors` would be previously generated by
#`python2 -m jcvi.compara.catalog ortholog` step.
# 
#
'''
CURRENT ACTUAL CODE FOR RUNNING/TESTING IN A NOTEBOOK WHEN IMPORTED/LOADED OR 
PASTED IN ANOTHER CELL:
get_if_chromosome_rearranged("S288c.DBVPG6765.anchors") 
'''
#
#
#*******************************************************************************
#


import sys
import os
import operator

###---------------------------HELPER FUNCTIONS--------------------------------###
def midpoint(items):
    '''
    takes a iterable of items and returns the midpoint (integer) of the first 
    and second values
    '''
    return int((int(items[0])+int(items[1]))/2)


###--------------------------END OF HELPER FUNCTIONS--------------------------###
###--------------------------END OF HELPER FUNCTIONS--------------------------###


#*******************************************************************************
###------------------------'main' function of script---------------------------##
def get_if_chromosome_rearranged(anchors_file):
    '''
    Main function of script.

    It will take an anchors file made by MCscan and return if the chromosome 
    (or genome for single chromosome genomes such as mitochondria) is 
    rearranged.

    Example calling function:
    get_if_chromosome_rearranged("S288c.DBVPG6765.anchors") 

    That file `S288c.DBVPG6765.anchors` would be previously generated by
    `python2 -m jcvi.compara.catalog ortholog` step.


    Script meant to be pasteable in a Jupyter notebook as well. The obvious use 
    case for that is when working in the Jupyter notebook environment.

    This is a simplified version of the script 
    `get_if_chromosome_rearranged_func_based_on_mcscan.py`.
    '''
    # Read and parse the anchors file to get the query and subect equivalent 
    # ids - first and second colums are qbed and sbed ids, respectively
    ''' Example anchors file
    ###
    s2ATP6  n4ATP6  1150
    s2COB   n4COB   1770
    s2OLI1  n4OLI1  357
    s2VAR1  n4VAR1  1440
    s2COX2  n4COX2  1120
    s2COX3  n4COX3  1210
    s2COX1  n4COX1  2380
    s2ATP8  n4ATP8  225
    '''
    qids_to_sids_correspondences = {}
    with open(anchors_file, 'r') as input_handler:
        for line in input_handler:
            if not line.startswith('#'):
                cols = line.split("\t")
                qids_to_sids_correspondences[cols[0]] = cols[1]


    # Using the name of the anchors file, assume the `.bed` names and read
    # contents of both.
    beds_part = anchors_file[:anchors_file.index(".anchors")]
    qbed = beds_part.split(".")[0] + ".bed"
    sbed = beds_part.split(".")[1] + ".bed"
    # Give feedback like so `Assuming --qbed=S288c.bed --sbed=N44.bed`
    sys.stderr.write("\nAssuming --qbed={} --sbed={}.".format(qbed,sbed))
    bed_files = (qbed,sbed)

    # Parse the contents in the BED file first to put them in ROUGH order of 
    # how they would be along chromsome. This should be actually moot as 
    # according to running `!python2 -m jcvi.formats.gff bed`, the default is 
    # to sort when the bed file is made from the gff3 if following the normal 
    # workflow, see 
    # https://github.com/tanghaibao/jcvi/wiki/MCscan-(Python-version)#workflow 
    # and so just putting here mostly in case I forget that and come to the 
    # Bed file from another route and expect order not to matter in upstream
    # steps. This probably would handle any naive assumptions like that.
    # MORE ON THIS:
    # I am opting to simplify dealing with the coordinates and just use 
    # midpoints instead of requiring pre-sorting of BED file. Should work for 
    # most things. But I imagine with slightly different sized genes on another 
    # strand, when overlapping, they could appear to move in order because 
    # using midpoint. So that is why I noted above that 
    # `get_if_chromosome_rearranged_func_based_on_mcscan.py` might be safer in 
    # such cases.
    # Resources about this:
    # BEDOPS noted at http://seqanswers.com/forums/showthread.php?t=17721
    # http://seqanswers.com/forums/showthread.php?t=32100
    # https://www.biostars.org/p/64687/
    '''Example bed file
    chrMT   0   780 s2ATP6  0   +
    chrMT   8054    15163   s2COB   0   +
    chrMT   18239   18470   s2OLI1  0   +
    chrMT   20417   21614   s2VAR1  0   +
    chrMT   45267   46023   s2COX2  0   +
    chrMT   50722   51532   s2COX3  0   +
    chrMT   71125   84008   s2COX1  0   +
    chrMT   84972   85119   s2ATP8  0   +
    '''
    # Extract midpoint using start and end (columns 1 and 2 in zero-indexed 
    # python), without regard to strand and list along with the line. Tuple in 
    # list will be `(<line>,<midpoint>)`
    qbed_lines = []
    sbed_lines = []
    for indx,current_bed in enumerate(bed_files):
        if indx == 0:
            list_to_build = qbed_lines
        else:
            list_to_build = sbed_lines
        with open(current_bed, 'r') as input_handler:
            for line in input_handler:
                if not line.startswith('#'):
                    cols = line.split("\t")
                    list_to_build.append((line,midpoint((cols[1],cols[2]))))
    # Sort based on midpoint to sort (roughly)
    qbed_lines.sort(key=operator.itemgetter(1))
    sbed_lines.sort(key=operator.itemgetter(1))
    bed_file_lines = (qbed_lines,sbed_lines)

    # Parse `.bed` files contents (now semi-sorted) -- column 4 (3 in 
    # zero-indexed python) is gene id; make list of the ids in order as they 
    # appear. Example bed file is above in same section.
    qbed_ids_in_order = []
    sbed_ids_in_order = []
    for indx,current_bed in enumerate(bed_file_lines):
        if indx == 0:
            list_to_build = qbed_ids_in_order
        else:
            list_to_build = sbed_ids_in_order
        for line_pos_tuple in current_bed:
            line = line_pos_tuple[0]
            if not line.startswith('#'):
                cols = line.split("\t")
                list_to_build.append(cols[3])

    # Determine location of corresponding ids in each bed file
    qbed_loc = []
    sbed_loc = []
    for id_ in qids_to_sids_correspondences:
        qbed_loc.append(qbed_ids_in_order.index(id_))
        sbed_loc.append(
            sbed_ids_in_order.index(qids_to_sids_correspondences[id_]))

    # Compare order of equivalent ids to see if rearranged or not
    return qbed_loc != sbed_loc #qbed_loc == sbed_loc if not rearranged, so 
    # since testing if rearranged, want `True` when `qbed_loc != sbed_loc`, 
    # i.e., rearranged. Note that for Python 2, the order of location positions 
    # will most likely not won't be strictly ascending for the query. This is
    # because here we are iterating on the keys in `qids_to_sids_correspondences` 
    # and dictonaries in Python 2 and Python 3 get built differently with
    # Python 2 not being placed in order of addition. However, because both
    # `qbed_loc` and `sbed_loc` are being built from the same sequence of ids_ 
    # in the interation, the check for rearrangment still works. If they are in 
    # the same order, the built lists will be the same even if those built lists
    # don't have an ascending order.

###--------------------------END OF MAIN FUNCTION----------------------------###
###--------------------------END OF MAIN FUNCTION----------------------------###


#*******************************************************************************
###------------------------'main' section of script---------------------------##
def main():
    """ Main entry point of the script """
    # placing actual main action in a 'helper' script so can call that easily 
    # with a distinguishing name in Jupyter notebooks, where `main()` may get
    # assigned multiple times depending how many scripts imported/pasted in.
    kwargs = {}
    result = get_if_chromosome_rearranged(anchors_file,**kwargs)
    # using https://www.saltycrane.com/blog/2008/01/how-to-use-args-and-kwargs-in-python/#calling-a-function
    # to build keyword arguments to pass to the function above
    # (see https://stackoverflow.com/a/28986876/8508004 and
    # https://stackoverflow.com/a/1496355/8508004 
    # (maybe https://stackoverflow.com/a/7437238/8508004 might help too) for 
    # related help). Makes it easy to add more later.
    if result:
        print("Rearrangement DETECTED.")
    else:
        print("Not significantly rearranged.")


if __name__ == "__main__" and '__file__' in globals():
    """ This is executed when run from the command line """
    # Code with just `if __name__ == "__main__":` alone will be run if pasted
    # into a notebook. The addition of ` and '__file__' in globals()` is based
    # on https://stackoverflow.com/a/22923872/8508004
    # See also https://stackoverflow.com/a/22424821/8508004 for an option to 
    # provide arguments when prototyping a full script in the notebook.
    ###-----------------for parsing command line arguments-----------------------###
    import argparse
    parser = argparse.ArgumentParser(prog=
        'get_if_chromosome_rearranged_func_AFTER_MCscan_simplified.py',
        description="get_if_chromosome_rearranged_func_AFTER_MCscan_simplified.py \
        takes an anchor file made by MCscan FOR A SINGLE CHROMSOOMES and \
        returns if the chromosome (or \
        genome for single chromosome genomes such as mitochondria) is \
        rearranged. Also needs associated `.bed` files. \
        **** Script by Wayne Decatur   \
        (fomightez @ github) ***")

    parser.add_argument("anchors_file", help="Name of file of the `.anchors` \
        file generated by MCscan `python2 -m jcvi.compara.catalog ortholog` \
        step. \
        ", metavar="ALIGNMENT_FILE")


    #I would also like trigger help to display if no arguments provided because 
    # need at least one for url
    if len(sys.argv)==1:    #from http://stackoverflow.com/questions/4042452/display-help-message-with-python-argparse-when-script-is-called-without-any-argu
        parser.print_help()
        sys.exit(1)
    args = parser.parse_args()
    anchors_file = args.anchors_file

    main()
#*******************************************************************************
###-***********************END MAIN PORTION OF SCRIPT***********************-###
#*******************************************************************************
